#version 460
#extension GL_EXT_debug_printf : enable

#define NUM_PRINTABLE_CHARS 95

struct Line {
	vec2 p1;
	vec2 p2;
};

struct GlyphOffset {
	uint offset;
	uint num_lines;
	vec2 padding;
};

layout(push_constant) uniform PushConstants {
	float glyph_width;
	float glyph_height;
	uint glyph_atlas_width;
	uint glyph_atlas_height;
} pc;

layout(binding = 0, r16ui) uniform writeonly uimage2D glyph_atlas;
layout(binding = 1) readonly buffer Lines {
	Line data[];
} glyph_lines;
layout(binding = 2) readonly buffer GlyphOffsets {
	GlyphOffset data[];
} glyph_offsets;

layout (local_size_x = 1, local_size_y = 1) in;
void main() {
	uvec2 id = gl_GlobalInvocationID.xy;

	uint num_glyphs_per_row = uint(imageSize(glyph_atlas).x / pc.glyph_atlas_width);
	uint char_index = uint(id.y / pc.glyph_atlas_height) * num_glyphs_per_row + uint(id.x / pc.glyph_atlas_width);
	if(char_index >= NUM_PRINTABLE_CHARS) {
		return;
	}

	uint result = 0;

	vec2 pixel_top_left = {
		id.x - pc.glyph_atlas_width * floor(id.x / pc.glyph_atlas_width),
		id.y - pc.glyph_atlas_height * floor(id.y / pc.glyph_atlas_height)
	};

	for(int i = 0; i < glyph_offsets.data[char_index].num_lines; ++i) {
		Line l = glyph_lines.data[glyph_offsets.data[char_index].offset + i];
		vec2 p1 = l.p1;
		vec2 p2 = l.p2;
		for(uint y = 0; y < 4; ++y) {
			for(uint x = 0; x < 4; ++x) {
				vec2 p = pixel_top_left + vec2(0.2f) + vec2(x * 0.2f, y * 0.2f);
			
				if(p.y < p2.y && p.y >= p1.y) {
					float dx = p2.x - p1.x;
					float dy = p2.y - p1.y;
					if(dy == 0.0f) {
					   continue;
					}
					float line_x = (p.y - p1.y) * (dx / dy) + p1.x;
					if(p.x > line_x) {
						uint mask = 1u << (y * 4u + (3u - x));
						result ^= mask;
					}
				}
			}
		}
	}

	imageStore(glyph_atlas, ivec2(id.xy), uvec4(result));
}